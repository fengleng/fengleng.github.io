<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="java基础">
<meta property="og:type" content="article">
<meta property="og:title" content="2019-9-13-java题">
<meta property="og:url" content="http://yoursite.com/2019/09/04/2019-9-13-java题/index.html">
<meta property="og:site_name" content="峰冷">
<meta property="og:description" content="java基础">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://img-blog.csdn.net/20160201154828658?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdn.net/20150408174308284">
<meta property="og:image" content="https://img-blog.csdn.net/20150408153246930">
<meta property="og:image" content="https://img-blog.csdn.net/20150408153213362">
<meta property="og:image" content="https://img-blog.csdn.net/20150409102658882">
<meta property="og:image" content="https://img-blog.csdn.net/20150412180839610">
<meta property="og:image" content="https://img-blog.csdn.net/20150414123625761">
<meta property="og:image" content="https://img-blog.csdn.net/20150414123848158">
<meta property="og:image" content="https://img-blog.csdn.net/20150414123813701">
<meta property="og:updated_time" content="2019-09-13T06:29:17.233Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="2019-9-13-java题">
<meta name="twitter:description" content="java基础">
<meta name="twitter:image" content="https://img-blog.csdn.net/20160201154828658?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
  <link rel="canonical" href="http://yoursite.com/2019/09/04/2019-9-13-java题/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>2019-9-13-java题 | 峰冷</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">


  <div class="container sidebar-position-left">
    <div class="headband"></div>
    <a href="https://github.com/fengleng" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">峰冷</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/04/2019-9-13-java题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田松">
      <meta itemprop="description" content="真心喜欢应该是宁愿自己妥协也不会舍得骂人的 如果骂人，哪里有什么真诚在里面 我不想因为你哭了">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="峰冷">
    </span>
      <header class="post-header">
        
        <h1 class="post-title" itemprop="name headline">2019-9-13-java题

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-04 15:50:50" itemprop="dateCreated datePublished" datetime="2019-09-04T15:50:50+08:00">2019-09-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-13 14:29:17" itemprop="dateModified" datetime="2019-09-13T14:29:17+08:00">2019-09-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java基础/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>java基础</p>
<a id="more"></a>

<p>2013年年底的时候，我看到了网上流传的一个叫做《Java面试题大全》的东西，认真的阅读了以后发现里面的很多题目是重复且没有价值的题目，还有不少的参考答案也是错误的，于是我花了半个月时间对这个所谓的《Java面试大全》进行了全面的修订并重新发布在我的CSDN博客。在修订的过程中，参照了当时JDK最新版本（Java 7）给出了题目的答案和相关代码，去掉了EJB 2.x、JSF等无用内容或过时内容，补充了数据结构和算法、大型网站技术架构、设计模式、UML、Spring MVC等内容并对很多知识点进行了深入的剖析，例如hashCode方法的设计、垃圾收集、并发编程、数据库事务等。当时我甚至希望把面试中经常出现的操作系统、数据库、软件测试等内容也补充进去，但是由于各种原因，最终只整理出了150道面试题。让我欣慰的是，这150道题还是帮助到了很多人，而且在我CSDN博客上的总访问量超过了5万次，最终还被很多网站和个人以原创的方式转载了。最近一年内，用百度搜索”Java面试”我写的这些东西基本上都排在搜索结果的前5名，这让我觉得”亚历山大”，因为我写的这些东西一旦不准确就可能误导很多人。2014年的时候我又整理了30道题，希望把之前遗漏的面试题和知识点补充上去，但是仍然感觉挂一漏万，而且Java 8问世后很多新的东西又需要去总结和整理。为此，我不止一次的修改了之前的180题，修改到自己已经感觉有些疲惫或者厌烦了。2014年至今，自己带的学生又有很多走上了Java程序员、Java工程师的工作岗位，他们的面试经验也还没来得及跟大家分享，冥冥之中似乎有一股力量在刺激我要重新写一篇《Java面试题全集》，于是这篇文章就诞生了。请不要责备我把那些出现过的内容又写了一次，因为每次写东西就算是重复的内容，我也需要对编程语言和相关技术进行重新思考，不仅字斟句酌更是力求至臻完美，所以请相信我分享的一定是更新的、更好的、更有益的东西，这些内容也诉说着一个职业程序员和培训师的思想、精神和情感。</p>
<p>1、面向对象的特征有哪些方面？<br>答：面向对象的特征主要有以下几个方面：<br>- 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。<br>- 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。<br>- 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。<br>- 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</p>
<p><strong>2、访问修饰符public,private,protected,以及不写（默认）时的区别？</strong><br>答：</p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">当前类</th>
<th align="left">同 包</th>
<th align="left">子 类</th>
<th align="left">其他包</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
<tr>
<td align="left">protected</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">×</td>
</tr>
<tr>
<td align="left">default</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">×</td>
<td align="left">×</td>
</tr>
<tr>
<td align="left">private</td>
<td align="left">√</td>
<td align="left">×</td>
<td align="left">×</td>
<td align="left">×</td>
</tr>
</tbody></table>
<p>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符只能是public或默认，类的成员（包括内部类）的修饰符可以是以上四种。</p>
<p>3、String 是最基本的数据类型吗？<br>答：不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。</p>
<p>4、float f=3.4;是否正确？<br>答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。</p>
<p>5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？<br>答：对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。</p>
<p>6、Java有没有goto？<br>答：goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）</p>
<p>7、int和Integer有什么区别？<br>答：Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。<br>Java 为每个原始类型提供了包装类型：<br>- 原始类型: boolean，char，byte，short，int，long，float，double<br>- 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p>
<p>public class Test03 {</p>
<pre><code>System.out.println(f1 == f2);        System.out.println(f3 == f4);    }}</code></pre><p>  public static Integer valueOf(int i) {        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)            return IntegerCache.cache[i + (-IntegerCache.low)];        return new Integer(i);    }</p>
<p> private static class IntegerCache {        static final int low = -128;        static final int high;        static final Integer cache[];</p>
<pre><code>cache = new Integer[(high - low) + 1];            int j = low;            for(int k = 0; k &lt; cache.length; k++)                cache[k] = new Integer(j++);</code></pre><p>​        private IntegerCache() {}    }</p>
<p>​    提醒：越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。</p>
<pre><code>补充：如果你熟悉JavaScript，那你可能更能感受到短路运算的强大，想成为JavaScript的高手就先从玩转短路运算开始吧。</code></pre><p>String str = new String(“hello”);</p>
<p>​    补充：较新版本的Java（从Java 6的某个更新开始）中使用了一项叫”逃逸分析”的技术，可以将一些局部对象放在栈上以提升对象的操作性能。</p>
<p>11、swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？答：在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p>
<pre><code>补充：我们为编写的类重写hashCode方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择31这个数？前两个问题的答案你可以自己百度一下，选择31是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num 等价于(num &lt;&lt; 5) - num，左移5位相当于乘以2的5次方再减去自身就相当于乘以31，现在的VM都能自动完成这个优化。




@Override    public int hashCode() {        final int prime = 31;        int result = 1;        result = prime * result + areaCode;        result = prime * result                + ((lineNumber == null) ? 0 : lineNumber.hashCode());        result = prime * result + ((prefix == null) ? 0 : prefix.hashCode());        return result;    }</code></pre><p>}</p>
<p>14、在Java中，如何跳出当前的多重嵌套循环？答：在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）</p>
<p>16、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？答：不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。</p>
<p>17、是否可以继承String类？答：String 类是final类，不可以被继承。</p>
<p>18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？答：是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。在C#中可以编写如下所示的代码，但是在Java中却做不到。</p>
<p>namespace CS01 {</p>
<pre><code>public static void Main (string[] args) {            int a = 5, b = 10;            swap (ref a, ref b);            // a = 10, b = 5;            Console.WriteLine (&quot;a = {0}, b = {1}&quot;, a, b);        }    }}</code></pre><p>19、String和StringBuilder、StringBuffer的区别？答：Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。</p>
<p>​    面试题2 - 请说出下面程序的输出。</p>
<p>​    public static void main(String[] args) {        String s1 = “Programming”;        String s2 = new String(“Programming”);        String s3 = “Program” + “ming”;        System.out.println(s1 == s2);        System.out.println(s1 == s3);        System.out.println(s1 == s1.intern());    }}</p>
<p>20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</p>
<p>21、描述一下JVM加载class文件的原理机制？答：JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：</p>
<p>22、char 型变量中能不能存贮一个中文汉字，为什么？答：char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。</p>
<p>23、抽象类（abstract class）和接口（interface）有什么异同？答：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。</p>
<p>/** * 扑克类（一副扑克） * @author 骆昊 * */public class Poker {    private static String[] suites = {“黑桃”, “红桃”, “草花”, “方块”};    private static int[] faces = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};</p>
<p>​    /**     * 构造器     *      */    public Poker() {        cards = new Card[52];        for(int i = 0; i &lt; suites.length; i++) {            for(int j = 0; j &lt; faces.length; j++) {                cards[i * 13 + j] = new Card(suites[i], faces[j]);            }        }    }</p>
<pre><code>/**     * 发牌     * @param index 发牌的位置     *      */    public Card deal(int index) {        return cards[index];    }</code></pre><p>​        public Card(String suite, int face) {            this.suite = suite;            this.face = face;        }</p>
<p>测试代码：</p>
<p>​    public static void main(String[] args) {        Poker poker = new Poker();        poker.shuffle();                // 洗牌        Poker.Card c1 = poker.deal(0);  // 发第一张牌        // 对于非静态内部类Card        // 只有通过其外部类Poker对象才能创建Card对象        Poker.Card c2 = poker.new Card(“红心”, 1);    // 自己创建一张牌</p>
<pre><code>面试题 - 下面的代码哪些地方会产生编译错误？</code></pre><p>​    class Inner {}</p>
<p>​    public void bar() { new Inner(); }</p>
<pre><code>注意：Java中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中foo和main方法都是静态方法，静态方法中没有this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做：</code></pre><p>25、Java 中会存在内存泄漏吗，请简单描述。答：理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存泄露。</p>
<p>public class MyStack<t> {    private T[] elements;    private int size = 0;</t></p>
<p>​    public MyStack() {        elements = (T[]) new Object[INIT_CAPACITY];    }</p>
<pre><code>public T pop() {        if(size == 0)             throw new EmptyStackException();        return elements[--size];    }</code></pre><p>上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。</p>
<p>27、阐述静态变量和实例变量的区别。答：静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。</p>
<p>28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。</p>
<p>import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;</p>
<p>​    private MyUtil() {        throw new AssertionError();    }</p>
<pre><code>ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray());        ObjectInputStream ois = new ObjectInputStream(bin);        return (T) ois.readObject();</code></pre><p>下面是测试代码：</p>
<p>/** * 人类 * @author 骆昊 * */class Person implements Serializable {    private static final long serialVersionUID = -9102017020286042305L;</p>
<p>​    public Person(String name, int age, Car car) {        this.name = name;        this.age = age;        this.car = car;    }</p>
<p>​    public void setName(String name) {        this.name = name;    }</p>
<p>​    public void setAge(int age) {        this.age = age;    }</p>
<p>​    public void setCar(Car car) {        this.car = car;    }</p>
<p>}</p>
<pre><code>private String brand;       // 品牌    private int maxSpeed;       // 最高时速




public String getBrand() {        return brand;    }</code></pre><p>​    public int getMaxSpeed() {        return maxSpeed;    }</p>
<p>​    @Override    public String toString() {        return “Car [brand=” + brand + “, maxSpeed=” + maxSpeed + “]”;    }</p>
<p>30、GC是什么？为什么要有GC？答：GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。</p>
<p>与垃圾回收相关的JVM参数：</p>
<p>31、String s = new String(“xyz”);创建了几个字符串对象？答：两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p>
<p>33、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？答：可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。</p>
<p>35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</p>
<p>37、指出下面程序的运行结果。</p>
<p>​    static {        System.out.print(“1”);    }</p>
<p>class B extends A{</p>
<p>​    public B() {        System.out.print(“b”);    }}</p>
<p>​    public static void main(String[] args) {        A ab = new B();        ab = new B();    }</p>
<p>答：执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。</p>
<p>38、数据类型之间的转换：- 如何将字符串转换为基本数据类型？- 如何将基本数据类型转换为字符串？答：- 调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型；- 一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf()方法返回相应字符串</p>
<p>   public static String reverse(String originStr) {        if(originStr == null || originStr.length() &lt;= 1)            return originStr;        return reverse(originStr.substring(1)) + originStr.charAt(0);    }</p>
<p>String s1 = “你好”;String s2 = new String(s1.getBytes(“GB2312”), “ISO-8859-1”);</p>
<p>public class DateTimeTest {    public static void main(String[] args) {        Calendar cal = Calendar.getInstance();        System.out.println(cal.get(Calendar.YEAR));        System.out.println(cal.get(Calendar.MONTH));    // 0 - 11        System.out.println(cal.get(Calendar.DATE));        System.out.println(cal.get(Calendar.HOUR_OF_DAY));        System.out.println(cal.get(Calendar.MINUTE));        System.out.println(cal.get(Calendar.SECOND));</p>
<p>问题2：以下方法均可获得该毫秒数。</p>
<p>问题3：代码如下所示。</p>
<p>问题4：利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化。Java 8中可以用java.time.format.DateTimeFormatter来格式化时间日期，代码如下所示。</p>
<p>class DateFormatTest {</p>
<pre><code>// Java 8        DateTimeFormatter newFormatter = DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd&quot;);        LocalDate date2 = LocalDate.now();        System.out.println(date2.format(newFormatter));    }}</code></pre><p>42、打印昨天的当前时刻。答：<br>import java.util.Calendar;</p>
<p>在Java 8中，可以用下面的代码实现相同的功能。</p>
<p>class YesterdayCurrent {</p>
<p>​        System.out.println(yesterday);    }}</p>
<p>​    补充：上面列出的四点是网上流传的所谓的标准答案。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民，因此JavaScript支持函数式编程，可以使用Lambda函数和闭包（closure），当然Java 8也开始支持函数式编程，提供了对Lambda表达式以及函数式接口的支持。对于这类问题，在面试的时候最好还是用自己的语言回答会更加靠谱，不要背网上所谓的标准答案。</p>
<p>assert(a &gt; 0); // throws an AssertionError if a &lt;= 0</p>
<p>要在运行时启用断言，可以在启动JVM时使用-enableassertions或者-ea标记。要在运行时选择禁用断言，可以在启动JVM时使用-da或者-disableassertions标记。要在系统类中启用或禁用断言，可使用-esa或-dsa标记。还可以在包的基础上启用或者禁用断言。</p>
<p>45、Error和Exception有什么区别？答：Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
<p>class StackOverflowErrorTest {</p>
<pre><code>提示：用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候就不再继续递归）。


注意：在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，就会返回修改后的值。显然，在finally中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java中也可以通过提升编译器的语法检查级别来产生警告或错误，Eclipse中可以在如图所示的地方进行设置，强烈建议将此项设置为编译错误。</code></pre><p><img src="https://img-blog.csdn.net/20160201154828658?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>48、运行时异常与受检异常有何异同？答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective Java中对异常的使用给出了以下指导原则：- 不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）- 对可以恢复的情况使用受检异常，对编程错误使用运行时异常- 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）- 优先使用标准的异常- 每个方法抛出的异常都要有文档- 保持异常的原子性- 不要在catch中忽略掉捕获到的异常</p>
<p>50、阐述final、finally、finalize的区别。答：- final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final的方法也同样只能使用，不能在子类中被重写。- finally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。- finalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。</p>
<p>try {    throw new ExampleB(“b”)} catch（ExampleA e）{    System.out.println(“ExampleA”);} catch（Exception e）{    System.out.println(“Exception”);}</p>
<pre><code>面试题 - 说出下面代码的运行结果。（此题的出处是《Java编程思想》一书）</code></pre><p>class Human {</p>
<p>52、List、Set、Map是否继承自Collection接口？答：List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。</p>
<pre><code>补充：遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是Has-A关系而不是Is-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是Has-A关系（关联）或Use-A关系（依赖）。同理，Stack类继承Vector也是不正确的。Sun公司的工程师们也会犯这种低级错误，让人唏嘘不已。</code></pre><p>55、List、Map、Set三个接口存取元素时，各有什么特点？答：List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</p>
<p>public class Student implements Comparable<student> {    private String name;        // 姓名    private int age;            // 年龄</student></p>
<pre><code>@Override    public String toString() {        return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;    }</code></pre><p>}<br>import java.util.Set;import java.util.TreeSet;</p>
<p>​    public static void main(String[] args) {        Set<student> set = new TreeSet&lt;&gt;();     // Java 7的钻石语法(构造器后面的尖括号中不需要写类型)        set.add(new Student(“Hao LUO”, 33));        set.add(new Student(“XJ WANG”, 32));        set.add(new Student(“Bruce LEE”, 60));        set.add(new Student(“Bob YANG”, 22));</student></p>
<p>例子2：</p>
<p>​    public Student(String name, int age) {        this.name = name;        this.age = age;    }</p>
<pre><code>/**     * 获取学生年龄     */    public int getAge() {        return age;    }</code></pre><p>}</p>
<p>import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;</p>
<p>​    public static void main(String[] args) {        List<student> list = new ArrayList&lt;&gt;();     // Java 7的钻石语法(构造器后面的尖括号中不需要写类型)        list.add(new Student(“Hao LUO”, 33));        list.add(new Student(“XJ WANG”, 32));        list.add(new Student(“Bruce LEE”, 60));        list.add(new Student(“Bob YANG”, 22));</student></p>
<p>​            @Override            public int compare(Student o1, Student o2) {                return o1.getName().compareTo(o2.getName());    // 比较学生姓名            }        });</p>
<p>57、Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?答：sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</p>
<p>58、线程的sleep()方法和yield()方法有什么区别？答：① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</p>
<p>60、请说出与线程同步以及线程调度相关的方法。答：- wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；- sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；- notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；- notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；<br>    补充：Java 5通过Lock接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了newCondition()方法来产生用于线程之间通信的Condition对象；此外，Java 5还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。</p>
<p>​    银行账户类：</p>
<p>​    /**     * 存款     * @param money 存入金额     */    public void deposit(double money) {        double newBalance = balance + money;        try {            Thread.sleep(10);   // 模拟此业务需要一段处理时间        }        catch(InterruptedException ex) {            ex.printStackTrace();        }        balance = newBalance;    }</p>
<p>​    存钱线程类：</p>
<pre><code>public AddMoneyThread(Account account, double money) {        this.account = account;        this.money = money;    }</code></pre><p>}</p>
<p>import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;</p>
<p>​    public static void main(String[] args) {        Account account = new Account();        ExecutorService service = Executors.newFixedThreadPool(100);</p>
<p>​        service.shutdown();</p>
<p>​        System.out.println(“账户余额: “ + account.getBalance());    }}</p>
<p>​    在银行账户的存款（deposit）方法上同步（synchronized）关键字</p>
<p>​    /**     * 存款     * @param money 存入金额     */    public synchronized void deposit(double money) {        double newBalance = balance + money;        try {            Thread.sleep(10);   // 模拟此业务需要一段处理时间        }        catch(InterruptedException ex) {            ex.printStackTrace();        }        balance = newBalance;    }</p>
<p>​    在线程调用存款方法时对银行账户进行同步</p>
<pre><code>public AddMoneyThread(Account account, double money) {        this.account = account;        this.money = money;    }</code></pre><p>}</p>
<p>import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;</p>
<p>​    /**     * 存款     *      * @param money     *            存入金额     */    public void deposit(double money) {        accountLock.lock();        try {            double newBalance = balance + money;            try {                Thread.sleep(10); // 模拟此业务需要一段处理时间            }            catch (InterruptedException ex) {                ex.printStackTrace();            }            balance = newBalance;        }        finally {            accountLock.unlock();        }    }</p>
<p>按照上述三种方式对代码进行修改后，重写执行测试代码Test01，将看到最终的账户余额为100元。当然也可以使用Semaphore或CountdownLatch来实现同步。</p>
<pre><code>补充：Java 5以后创建线程还有第三种方式：实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值，代码如下所示：</code></pre><p>​    public MyTask(int upperBounds) {        this.upperBounds = upperBounds;    }</p>
<p>}</p>
<p>​    public static void main(String[] args) throws Exception {        List&lt;Future<integer>&gt; list = new ArrayList&lt;&gt;();        ExecutorService service = Executors.newFixedThreadPool(10);        for(int i = 0; i &lt; 10; i++) {            list.add(service.submit(new MyTask((int) (Math.random() * 100))));        }</integer></p>
<p>​        System.out.println(sum);    }}</p>
<p>63、举例说明同步和异步。答：如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。</p>
<p>65、什么是线程池（thread pool）？答：在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：- newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。- newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。- newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。- newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。- newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<p>66、线程的基本状态以及状态之间的关系？答：<br>    说明：其中Running表示运行状态，Runnable表示就绪状态（万事俱备，只欠CPU），Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。</p>
<p>68、Java中如何实现序列化，有什么意义？答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆（可以参考第29题）。</p>
<pre><code>面试题 - 编程实现文件拷贝。（这个题目在笔试的时候经常出现，下面的代码给出了两种实现方案）</code></pre><p>public final class MyUtil {</p>
<p>​    public static void fileCopy(String source, String target) throws IOException {        try (InputStream in = new FileInputStream(source)) {            try (OutputStream out = new FileOutputStream(target)) {                byte[] buffer = new byte[4096];                int bytesToRead;                while((bytesToRead = in.read(buffer)) != -1) {                    out.write(buffer, 0, bytesToRead);                }            }        }    }</p>
<p>​    注意：上面用到Java 7的TWR，使用TWR后可以不用在finally中释放外部资源 ，从而让代码更加优雅。</p>
<p>import java.io.BufferedReader;import java.io.FileReader;</p>
<p>​    // 工具类中的方法都是静态方式访问的因此将构造器私有不允许创建对象(绝对好习惯)    private MyUtil() {        throw new AssertionError();    }</p>
<p>}</p>
<p>import java.io.File;</p>
<p>​    public static void main(String[] args) {        File f = new File(“/Users/Hao/Downloads”);        for(File temp : f.listFiles()) {            if(temp.isFile()) {                System.out.println(temp.getName());            }        }    }}</p>
<p>import java.io.File;</p>
<p>​    public static void main(String[] args) {        showDirectory(new File(“/Users/Hao/Downloads”));    }</p>
<p>​    private static void _walkDirectory(File f, int level) {        if(f.isDirectory()) {            for(File temp : f.listFiles()) {                _walkDirectory(temp, level + 1);            }        }        else {            for(int i = 0; i &lt; level - 1; i++) {                System.out.print(“\t”);            }            System.out.println(f.getName());        }    }}</p>
<p>class ShowFileTest {</p>
<p>​            @Override            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)                    throws IOException {                System.out.println(file.getFileName().toString());                return FileVisitResult.CONTINUE;            }</p>
<p>72、用Java的套接字编程实现一个多线程的回显（echo）服务器。答：</p>
<p>public class EchoServer {</p>
<p>​    public static void main(String[] args) {                try(ServerSocket server = new ServerSocket(ECHO_SERVER_PORT)) {            System.out.println(“服务器已经启动…”);            while(true) {                Socket client = server.accept();                new Thread(new ClientHandler(client)).start();            }        } catch (IOException e) {            e.printStackTrace();        }    }</p>
<pre><code>public ClientHandler(Socket client) {            this.client = client;        }</code></pre><p>}</p>
<p>下面是一段回显客户端测试代码：</p>
<p>public class EchoClient {</p>
<p>如果希望用NIO的多路复用套接字实现服务器，代码如下所示。NIO的操作虽然带来了更好的性能，但是有些操作是比较底层的，对于初学者来说还是有些难于理解。</p>
<p>public class EchoServerNIO {</p>
<p>​    private static ServerSocketChannel serverChannel = null;    private static Selector selector = null;    // 多路复用选择器    private static ByteBuffer buffer = null;    // 缓冲区</p>
<pre><code>private static void init() {        try {            serverChannel = ServerSocketChannel.open();            buffer = ByteBuffer.allocate(BUFFER_SIZE);            serverChannel.socket().bind(new InetSocketAddress(ECHO_SERVER_PORT));            serverChannel.configureBlocking(false);            selector = Selector.open();            serverChannel.register(selector, SelectionKey.OP_ACCEPT);        } catch (Exception e) {            throw new RuntimeException(e);        }    }
















private static void handleKey(SelectionKey key) throws IOException {        SocketChannel channel = null;</code></pre><p>}</p>
<p>public final class CharsetHelper {    private static final String UTF_8 = “UTF-8”;    private static CharsetEncoder encoder = Charset.forName(UTF_8).newEncoder();    private static CharsetDecoder decoder = Charset.forName(UTF_8).newDecoder();</p>
<pre><code>public static ByteBuffer encode(CharBuffer in) throws CharacterCodingException{        return encoder.encode(in);    }</code></pre><p>73、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？答：XML文档定义分为DTD和Schema两种形式，二者都是对XML语法的约束，其本质区别在于Schema本身也是一个XML文件，可以被XML解析器解析，而且可以为XML承载的数据定义类型，约束能力较之DTD更强大。对XML的解析主要有DOM（文档对象模型，DocumentObjectModel）、SAX（Simple API for XML）和StAX（Java 6中引入的新的解析XML的方式，StreamingAPI forXML），其中DOM处理大型文件时其性能下降的非常厉害，这个问题是由DOM树结构占用的内存较多造成的，而且DOM解析方式必须在解析文件之前把整个文档装入内存，适合对XML的随机访问（典型的用空间换取时间的策略）；SAX是事件驱动型的XML解析方式，它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过事件回调代码来处理XML文件，适合对XML的顺序访问；顾名思义，StAX把重点放在流上，实际上StAX与其他解析方式的本质区别就在于应用程序能够把XML作为一个事件流来处理。将XML作为一组事件来处理的想法并不新颖（SAX就是这样做的），但不同之处在于StAX允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。</p>
<pre><code>补充：现在有很多时髦的软件（如Sublime）已经开始将配置文件书写成JSON格式，我们已经强烈的感受到XML的另一项功能也将逐渐被业界抛弃。


加载驱动。</code></pre><p>​    创建连接。</p>
<p>​    创建语句。</p>
<p>​    执行语句。</p>
<p>​    处理结果。</p>
<p>​    关闭资源。</p>
<p>​    提示：关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭ResultSet、再关闭Statement、在关闭Connection。上面的代码只关闭了Connection（连接），虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载驱动在JDBC 4.0中是可以省略的（自动从类路径中加载驱动），但是我们建议保留。</p>
<pre><code>补充：为了提供对存储过程的调用，JDBC API中还提供了CallableStatement接口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的SQL语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。</code></pre><p>78、在进行数据库编程时，连接池有什么作用？答：由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，释放连接需要进行TCP四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于Java的开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid等。</p>
<p>79、什么是DAO模式？答：DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</p>
<p><strong>80、事务的ACID是指什么？</strong> 答： - 原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败； - 一致性(Consistent)：事务结束后系统状态是一致的； - 隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态； - 持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。</p>
<blockquote>
<p><strong>补充：</strong>关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在5类问题，包括3类数据读取问题（脏读、不可重复读和幻读）和2类数据更新问题（第1类丢失更新和第2类丢失更新）。</p>
</blockquote>
<p>脏读（Dirty Read）：A事务读取B事务尚未提交的数据并在此基础上操作，而B事务执行回滚，那么A读取到的数据就是脏数据。</p>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">转账事务A</th>
<th align="left">取款事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T1</td>
<td align="left"></td>
<td align="left">开始事务</td>
</tr>
<tr>
<td align="left">T2</td>
<td align="left">开始事务</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T3</td>
<td align="left"></td>
<td align="left">查询账户余额为1000元</td>
</tr>
<tr>
<td align="left">T4</td>
<td align="left"></td>
<td align="left">取出500元余额修改为500元</td>
</tr>
<tr>
<td align="left">T5</td>
<td align="left">查询账户余额为500元（脏读）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T6</td>
<td align="left"></td>
<td align="left">撤销事务余额恢复为1000元</td>
</tr>
<tr>
<td align="left">T7</td>
<td align="left">汇入100元把余额修改为600元</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T8</td>
<td align="left">提交事务</td>
<td align="left"></td>
</tr>
</tbody></table>
<hr>
<p>不可重复读（Unrepeatable Read）：事务A重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务B修改过了。</p>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">转账事务A</th>
<th align="left">取款事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T1</td>
<td align="left"></td>
<td align="left">开始事务</td>
</tr>
<tr>
<td align="left">T2</td>
<td align="left">开始事务</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T3</td>
<td align="left"></td>
<td align="left">查询账户余额为1000元</td>
</tr>
<tr>
<td align="left">T4</td>
<td align="left">查询账户余额为1000元</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T5</td>
<td align="left"></td>
<td align="left">取出100元修改余额为900元</td>
</tr>
<tr>
<td align="left">T6</td>
<td align="left"></td>
<td align="left">提交事务</td>
</tr>
<tr>
<td align="left">T7</td>
<td align="left">查询账户余额为900元（不可重复读）</td>
<td align="left"></td>
</tr>
</tbody></table>
<hr>
<p>幻读（Phantom Read）：事务A重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务B提交的行。</p>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">统计金额事务A</th>
<th align="left">转账事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T1</td>
<td align="left"></td>
<td align="left">开始事务</td>
</tr>
<tr>
<td align="left">T2</td>
<td align="left">开始事务</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T3</td>
<td align="left">统计总存款为10000元</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T4</td>
<td align="left"></td>
<td align="left">新增一个存款账户存入100元</td>
</tr>
<tr>
<td align="left">T5</td>
<td align="left"></td>
<td align="left">提交事务</td>
</tr>
<tr>
<td align="left">T6</td>
<td align="left">再次统计总存款为10100元（幻读）</td>
<td align="left"></td>
</tr>
</tbody></table>
<hr>
<p>第1类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了。</p>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">取款事务A</th>
<th align="left">转账事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T1</td>
<td align="left">开始事务</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T2</td>
<td align="left"></td>
<td align="left">开始事务</td>
</tr>
<tr>
<td align="left">T3</td>
<td align="left">查询账户余额为1000元</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T4</td>
<td align="left"></td>
<td align="left">查询账户余额为1000元</td>
</tr>
<tr>
<td align="left">T5</td>
<td align="left"></td>
<td align="left">汇入100元修改余额为1100元</td>
</tr>
<tr>
<td align="left">T6</td>
<td align="left"></td>
<td align="left">提交事务</td>
</tr>
<tr>
<td align="left">T7</td>
<td align="left">取出100元将余额修改为900元</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T8</td>
<td align="left">撤销事务</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T9</td>
<td align="left">余额恢复为1000元（丢失更新）</td>
<td align="left"></td>
</tr>
</tbody></table>
<hr>
<p>第2类丢失更新：事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失。</p>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">转账事务A</th>
<th align="left">取款事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T1</td>
<td align="left"></td>
<td align="left">开始事务</td>
</tr>
<tr>
<td align="left">T2</td>
<td align="left">开始事务</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T3</td>
<td align="left"></td>
<td align="left">查询账户余额为1000元</td>
</tr>
<tr>
<td align="left">T4</td>
<td align="left">查询账户余额为1000元</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T5</td>
<td align="left"></td>
<td align="left">取出100元将余额修改为900元</td>
</tr>
<tr>
<td align="left">T6</td>
<td align="left"></td>
<td align="left">提交事务</td>
</tr>
<tr>
<td align="left">T7</td>
<td align="left">汇入100元将余额修改为1100元</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T8</td>
<td align="left">提交事务</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T9</td>
<td align="left">查询账户余额为1100元（丢失更新）</td>
<td align="left"></td>
</tr>
</tbody></table>
<hr>
<p>数据并发访问所产生的问题，在有些场景下可能是允许的，但是有些场景下可能就是致命的，数据库通常会通过锁机制来解决数据并发访问问题，按锁定对象不同可以分为表级锁和行级锁；按并发事务锁定关系可以分为共享锁和独占锁，具体的内容大家可以自行查阅资料进行了解。直接使用锁是非常麻烦的，为此数据库为用户提供了自动锁机制，只要用户指定会话的事务隔离级别，数据库就会通过分析SQL语句然后为事务访问的资源加上合适的锁，此外，数据库还会维护这些锁通过各种手段提高系统的性能，这些对用户来说都是透明的（就是说你不用理解，事实上我确实也不知道）。ANSI/ISO SQL 92标准定义了4个等级的事务隔离级别，如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">脏读</th>
<th align="left">不可重复读</th>
<th align="left">幻读</th>
<th align="left">第一类丢失更新</th>
<th align="left">第二类丢失更新</th>
</tr>
</thead>
<tbody><tr>
<td align="left">READ UNCOMMITED</td>
<td align="left">允许</td>
<td align="left">允许</td>
<td align="left">允许</td>
<td align="left">不允许</td>
<td align="left">允许</td>
</tr>
<tr>
<td align="left">READ COMMITTED</td>
<td align="left">不允许</td>
<td align="left">允许</td>
<td align="left">允许</td>
<td align="left">不允许</td>
<td align="left">允许</td>
</tr>
<tr>
<td align="left">REPEATABLE READ</td>
<td align="left">不允许</td>
<td align="left">不允许</td>
<td align="left">允许</td>
<td align="left">不允许</td>
<td align="left">不允许</td>
</tr>
<tr>
<td align="left">SERIALIZABLE</td>
<td align="left">不允许</td>
<td align="left">不允许</td>
<td align="left">不允许</td>
<td align="left">不允许</td>
<td align="left">不允许</td>
</tr>
</tbody></table>
<p>需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。</p>
<p><strong>81、JDBC中如何进行事务处理？</strong>答：Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务；当事务完成后用commit()显式提交事务；如果在事务处理过程中发生异常则通过rollback()进行事务回滚。除此之外，从JDBC 3.0中还引入了Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。<img src="https://img-blog.csdn.net/20150408174308284" alt="这里写图片描述"></p>
<p>81、JDBC中如何进行事务处理？答：Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务；当事务完成后用commit()显式提交事务；如果在事务处理过程中发生异常则通过rollback()进行事务回滚。除此之外，从JDBC 3.0中还引入了Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。这里写图片描述</p>
<p>create table tb_user(id int primary key auto_increment,name varchar(20) unique not null,photo longblob);</p>
<p>import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;</p>
<p>​    public static void main(String[] args) {        Connection con = null;        try {            // 1. 加载驱动（Java6以上版本可以省略）            Class.forName(“com.mysql.jdbc.Driver”);            // 2. 建立连接            con = DriverManager.getConnection(“jdbc:mysql://localhost:3306/test”, “root”, “123456”);            // 3. 创建语句对象            PreparedStatement ps = con.prepareStatement(“insert into tb_user values (default, ?, ?)”);            ps.setString(1, “骆昊”);              // 将SQL语句中第一个占位符换成字符串            try (InputStream in = new FileInputStream(“test.jpg”)) {    // Java 7的TWR                ps.setBinaryStream(2, in);      // 将SQL语句中第二个占位符换成二进制流                // 4. 发出SQL语句获得受影响行数                System.out.println(ps.executeUpdate() == 1 ? “插入成功” : “插入失败”);            } catch(IOException e) {                System.out.println(“读取照片失败!”);            }        } catch (ClassNotFoundException | SQLException e) {     // Java 7的多异常捕获            e.printStackTrace();        } finally { // 释放外部资源的代码都应当放在finally中保证其能够得到执行            try {                if(con != null &amp;&amp; !con.isClosed()) {                    con.close();    // 5. 释放数据库连接                    con = null;     // 指示垃圾回收器可以回收该对象                }            } catch (SQLException e) {                e.printStackTrace();            }        }    }}</p>
<pre><code>说明：计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支持。


面试题： - 如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京市(朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？</code></pre><p>class RegExpTest {</p>
<p>​    说明：上面的正则表达式中使用了懒惰匹配和前瞻，如果不清楚这些内容，推荐读一下网上很有名的《正则表达式30分钟入门教程》。</p>
<p>86、如何通过反射创建对象？答：- 方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance()- 方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”);</p>
<p>import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.ArrayList;import java.util.List;</p>
<pre><code>private ReflectionUtil() {        throw new AssertionError();    }










    try {            for(int i = 0; i &lt; fs.length - 1; i++) {                Field f = clazz.getDeclaredField(fs[i]);                f.setAccessible(true);                target = f.get(target);                clazz = target.getClass();            }








/**     * 通过反射给对象的指定字段赋值     * @param target 目标对象     * @param fieldName 字段的名称     * @param value 值     */    public static void setValue(Object target, String fieldName, Object value) {        Class&lt;?&gt; clazz = target.getClass();        String[] fs = fieldName.split(&quot;\\.&quot;);        try {            for(int i = 0; i &lt; fs.length - 1; i++) {                Field f = clazz.getDeclaredField(fs[i]);                f.setAccessible(true);                Object val = f.get(target);                if(val == null) {                    Constructor&lt;?&gt; c = f.getType().getDeclaredConstructor();                    c.setAccessible(true);                    val = c.newInstance();                    f.set(target, val);                }                target = val;                clazz = target.getClass();            }</code></pre><p>}</p>
<p>import java.lang.reflect.Method;</p>
<p>​    public static void main(String[] args) throws Exception {        String str = “hello”;        Method m = str.getClass().getMethod(“toUpperCase”);        System.out.println(m.invoke(str));  // HELLO    }}</p>
<p><strong>89、简述一下面向对象的”六原则一法则”。</strong>答： - 单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，就如同葵花宝典或辟邪剑谱的中心思想就八个字”欲练此功必先自宫”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫”因为专注，所以专业”，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）- 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）- 依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）- 接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）- 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）- 迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到”低耦合”，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。）</p>
<p><img src="https://img-blog.csdn.net/20150408153246930" alt="这里写图片描述"><img src="https://img-blog.csdn.net/20150408153213362" alt="这里写图片描述"></p>
<p>91、用Java写一个单例类。答：- 饿汉式单例    懒汉式单例    注意：实现一个单例有两点注意事项，①将构造器私有，不允许外界通过构造器创建对象；②通过公开的静态方法向外界返回类的唯一实例。这里有一个问题可以思考：Spring的IoC容器可以为普通的类创建单例，它是怎么做到的呢？94、用Java写一个冒泡排序。答：冒泡排序几乎是个程序员都写得出来，但是面试的时候如何写一个逼格高的冒泡排序却不是每个人都能做到，下面提供一个参考代码：/<em>* * 排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们可以相互替换) * @author骆昊 * <em>/public interface Sorter {   /*</em>    * 排序    * @param list 待排序的数组    * @param comp 比较两个对象的比较器    <em>/   public <t> void sort(T[] list, Comparator<t> comp);}/*</t></t></em> * 冒泡排序 *  * @author骆昊 * */public class BubbleSorter implements Sorter {    @Override    public <t> void sort(T[] list, Comparator<t> comp) {        boolean swapped = true;        for (int i = 1, len = list.length; i &lt; len &amp;&amp; swapped; ++i) {            swapped = false;            for (int j = 0; j &lt; len - i; ++j) {                if (comp.compare(list[j], list[j + 1]) &gt; 0) {                    T temp = list[j];                    list[j] = list[j + 1];                    list[j + 1] = temp;                    swapped = true;                }            }        }    }}import java.util.Comparator;   public static &lt;T extends Comparable<t>&gt; int binarySearch(T[] x, T key) {      return binarySearch(x, 0, x.length- 1, key);   }   // 使用递归实现的二分查找   private static&lt;T extends Comparable<t>&gt; int binarySearch(T[] x, int low, int high, T key) {      if(low &lt;= high) {        int mid = low + ((high -low) &gt;&gt; 1);        if(key.compareTo(x[mid])== 0) {           return mid;        }        else if(key.compareTo(x[mid])&lt; 0) {           return binarySearch(x,low, mid - 1, key);        }        else {           return binarySearch(x,mid + 1, high, key);        }      }      return -1;   }}96、阐述Servlet和CGI的区别?答：Servlet与CGI的区别在于Servlet处于服务器进程中，它通过多线程方式运行其service()方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于Servlet。97、Servlet接口中有哪些方法？答：Servlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关：- void init(ServletConfig config) throws ServletException- void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException- void destory()- java.lang.String getServletInfo()- ServletConfig getServletConfig()98、转发（forward）和重定向（redirect）的区别？答：forward是容器中控制权的转向，是服务器请求资源，服务器直接访问目标地址的URL，把那个URL 的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。redirect就是服务器端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，因此从浏览器的地址栏中可以看到跳转后的链接地址，很明显redirect无法访问到服务器保护起来资源，但是可以从一个网站redirect到其他网站。forward更加高效，所以在满足需要时尽量使用forward（通过调用RequestDispatcher对象的forward()方法，该对象可以通过ServletRequest对象的getRequestDispatcher()方法获得），并且这样也有助于隐藏实际的链接；在有些情况下，比如需要访问一个其它服务器上的资源，则必须使用重定向（通过HttpServletResponse对象调用其sendRedirect()方法实现）。    补充：如果用Servlet来生成网页中的动态内容无疑是非常繁琐的工作，另一方面，所有的文本和HTML标签都是硬编码，即使做出微小的修改，都需要进行重新编译。JSP解决了Servlet的这些问题，它是Servlet很好的补充，可以专门用作为用户呈现视图（View），而Servlet作为控制器（Controller）专门负责处理用户请求并转发或重定向到某个页面。基于Java的Web开发很多都同时使用了Servlet和JSP。JSP页面其实是一个Servlet，能够运行Servlet的服务器（Servlet容器）通常也是JSP容器，可以提供JSP页面的运行环境，Tomcat就是一个Servlet/JSP容器。第一次请求一个JSP页面时，Servlet/JSP容器首先将JSP页面转换成一个JSP页面的实现类，这是一个实现了JspPage接口或其子接口HttpJspPage的Java类。JspPage接口是Servlet的子接口，因此每个JSP页面都是一个Servlet。转换成功后，容器会编译Servlet类，之后容器加载和实例化Java字节码，并执行它通常对Servlet所做的生命周期操作。对同一个JSP页面的后续请求，容器会查看这个JSP页面是否被修改过，如果修改过就会重新转换并重新编译并执行。如果没有则执行内存中已经存在的Servlet实例。我们可以看一段JSP代码对应的Java程序就知道一切了，而且9个内置对象的神秘面纱也会被揭开。&lt;%@ page pageEncoding=”UTF-8”%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme() + “://“ + request.getServerName() + “:” + request.getServerPort() + path + “/“;%&gt;  <body>    <h1>Hello, World!</h1>    <hr>    <h2>Current time is: &lt;%= new java.util.Date().toString() %&gt;</h2>  </body>package org.apache.jsp;public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase        implements org.apache.jasper.runtime.JspSourceDependent {    private static java.util.Map&lt;java.lang.String, java.lang.Long&gt; _jspx_dependants;    public java.util.Map&lt;java.lang.String, java.lang.Long&gt; getDependants() {        return _jspx_dependants;    }    public void _jspDestroy() {    }        try {            response.setContentType(“text/html;charset=UTF-8”);            pageContext = _jspxFactory.getPageContext(this, request, response,                    null, true, 8192, true);            _jspx_page_context = pageContext;            application = pageContext.getServletContext();            config = pageContext.getServletConfig();            session = pageContext.getSession();            out = pageContext.getOut();            _jspx_out = out;            String path = request.getContextPath();            String basePath = request.getScheme() + “://“                    + request.getServerName() + “:” + request.getServerPort()                    + path + “/“;// 以下代码通过输出流将HTML标签输出到浏览器中            out.write(“\r\n”);            out.write(“\r\n”);            out.write(“<!DOCTYPE html>\r\n”);            out.write(“<html>\r\n”);            out.write(“  <head><meta name="generator" content="Hexo 3.9.0">\r\n”);            out.write(“    &lt;base href=&quot;“);            out.print(basePath);            out.write(“&quot;&gt;\r\n”);            out.write(“    <title>首页</title>\r\n”);            out.write(“    &lt;style type=&quot;text/css&quot;&gt;\r\n”);            out.write(“    \t</head></html></t></t></t></t></em> { font-family: &quot;Arial&quot;; }\r\n”);            out.write(“    \r\n”);            out.write(“  \r\n”);            out.write(“  \r\n”);            out.write(“  <body>\r\n”);            out.write(“    <h1>Hello, World!</h1>\r\n”);            out.write(“    <hr>\r\n”);            out.write(“    <h2>Current time is: “);            out.print(new java.util.Date().toString());            out.write(“</h2>\r\n”);            out.write(“  </body>\r\n”);            out.write(“\r\n”);        } catch (java.lang.Throwable t) {            if (!(t instanceof javax.servlet.jsp.SkipPageException)) {                out = _jspx_out;                if (out != null &amp;&amp; out.getBufferSize() != 0)                    try {                        out.clearBuffer();                    } catch (java.io.IOException e) {                    }                if (_jspx_page_context != null)                    _jspx_page_context.handlePageException(t);                else                    throw new ServletException(t);            }        } finally {            _jspxFactory.releasePageContext(_jspx_page_context);        }    }}101、常用的Web服务器有哪些？答：Unix和Linux平台下使用最广泛的免费HTTP服务器是Apache服务器，而Windows平台的服务器通常使用IIS作为Web服务器。选择Web服务器应考虑的因素有：性能、安全性、日志和统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等。下面是对常见服务器的简介：- IIS：Microsoft的Web服务器产品，全称是Internet Information Services。IIS是允许在公共Intranet或Internet上发布信息的Web服务器。IIS是目前最流行的Web服务器产品之一，很多著名的网站都是建立在IIS的平台上。IIS提供了一个图形界面的管理工具，称为Internet服务管理器，可用于监视配置和控制Internet服务。IIS是一种Web服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供ISAPI(Intranet Server API）作为扩展Web服务器功能的编程接口；同时，它还提供一个Internet数据库连接器，可以实现对数据库的查询和更新。- Kangle：Kangle Web服务器是一款跨平台、功能强大、安全稳定、易操作的高性能Web服务器和反向代理服务器软件。此外，Kangle也是一款专为做虚拟主机研发的Web服务器。实现虚拟主机独立进程、独立身份运行。用户之间安全隔离，一个用户出问题不影响其他用户。支持PHP、ASP、ASP.NET、Java、Ruby等多种动态开发语言。- WebSphere：WebSphere Application Server是功能完善、开放的Web应用程序服务器，是IBM电子商务计划的核心部分，它是基于Java的应用环境，用于建立、部署和管理Internet和Intranet Web应用程序，适应各种Web应用程序服务器的需要。- WebLogic：WebLogic Server是一款多功能、基于标准的Web应用服务器，为企业构建企业应用提供了坚实的基础。针对各种应用开发、关键性任务的部署，各种系统和数据库的集成、跨Internet协作等Weblogic都提供了相应的支持。由于它具有全面的功能、对开放标准的遵从性、多层架构、支持基于组件的开发等优势，很多公司的企业级应用都选择它来作为开发和部署的环境。WebLogic Server在使应用服务器成为企业应用架构的基础方面一直处于领先地位，为构建集成化的企业级应用提供了稳固的基础。- Apache：目前Apache仍然是世界上用得最多的Web服务器，其市场占有率很长时间都保持在60%以上（目前的市场份额约40%左右）。世界上很多著名的网站都是Apache的产物，它的成功之处主要在于它的源代码开放、有一支强大的开发团队、支持跨平台的应用（可以运行在几乎所有的Unix、Windows、Linux系统平台上）以及它的可移植性等方面。- Tomcat：Tomcat是一个开放源代码、运行Servlet和JSP的容器。Tomcat实现了Servlet和JSP规范。此外，Tomcat还实现了Apache-Jakarta规范而且比绝大多数商业应用软件服务器要好，因此目前也有不少的Web服务器都选择了Tomcat。- Nginx：读作”engine x”，是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器。 Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。在2014年下半年，Nginx的市场份额达到了14%。103、讲解JSP中的四种作用域。答：JSP中的四种作用域包括page、request、session和application，具体来说：- page代表与一个页面相关的对象和属性。- request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。- session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。- application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。&lt;%@page isThreadSafe=”false”%&gt;    说明：如果将JSP或Servlet设置成单线程工作模式，会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。    <strong>补充：</strong>HTML5中可以使用Web Storage技术通过JavaScript来保存数据，例如可以使用localStorage和sessionStorage来保存用户会话的信息，也能够实现会话跟踪。常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对XML的输出应用XSLT等。编码过滤器的例子：import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebFilter;import javax.servlet.annotation.WebInitParam;    @Override    public void destroy() {    }    @Override    public void init(FilterConfig config) throws ServletException {        String encoding = config.getInitParameter(“encoding”);        if (encoding != null) {            defaultEncoding = encoding;        }    }}import java.io.File;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.Properties;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;@WebFilter(urlPatterns = {“/*”})public class DownloadCounterFilter implements Filter {    @Override    public void destroy() {        executorService.shutdown();    }            @Override            public void run() {                String value = downloadLog.getProperty(uri);                if(value == null) {                    downloadLog.setProperty(uri, “1”);                }                else {                    int count = Integer.parseInt(value);                    downloadLog.setProperty(uri, String.valueOf(++count));                }                try {                    downloadLog.store(new FileWriter(logFile), “”);                }                 catch (IOException e) {                    e.printStackTrace();                }            }        });        chain.doFilter(req, resp);    }}107、监听器有哪些作用和用法？答：Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示：①ServletContextListener：对Servlet上下文的创建和销毁进行监听。②ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。③HttpSessionListener：对Session的创建和销毁进行监听。④HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听。⑤ServletRequestListener：对请求对象的初始化和销毁进行监听。⑥ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.annotation.WebListener;    @Override    public void contextDestroyed(ServletContextEvent evt) {    }}import javax.servlet.ServletContext;import javax.servlet.annotation.WebListener;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;    @Override    public void sessionCreated(HttpSessionEvent event) {        ServletContext ctx = event.getSession().getServletContext();        int count = Integer.parseInt(ctx.getAttribute(“onLineCount”).toString());        count++;        ctx.setAttribute(“onLineCount”, count);        int maxOnLineCount = Integer.parseInt(ctx.getAttribute(“maxOnLineCount”).toString());        if (count &gt; maxOnLineCount) {            ctx.setAttribute(“maxOnLineCount”, count);            DateFormat df = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);            ctx.setAttribute(“date”, df.format(new Date()));        }    }    说明：这里使用了Servlet 3规范中的@WebListener注解配置监听器，当然你可以在web.xml文件中用<listener>标签配置监听器，如108题中所示。①配置Spring上下文加载监听器加载Spring配置文件并创建IoC容器：  <listener>     <listener-class>       org.springframework.web.context.ContextLoaderListener     </listener-class>  </listener> <filter>      <filter-name>openSessionInView</filter-name>      <filter-class>         org.springframework.orm.hibernate3.support.OpenSessionInViewFilter      </filter-class>  </filter>③配置会话超时时间为10分钟：④配置404和Exception的错误页面：  <error-page>      <exception-type>java.lang.Exception</exception-type>      <location>/error.jsp</location>  </error-page><security-constraint>      <web-resource-collection>          <web-resource-name>ProtectedArea</web-resource-name>          <url-pattern>/admin/*</url-pattern>          <http-method>GET</http-method>          <http-method>POST</http-method>      </web-resource-collection>      <auth-constraint>          <role-name>admin</role-name>      </auth-constraint>  </security-constraint>  <security-role>      <role-name>admin</role-name>  </security-role>    补充：如果Web提供了有价值的商业信息或者是敏感数据，那么站点的安全性就是必须考虑的问题。安全认证是实现安全性的重要手段，认证就是要解决“Are you who you say you are?”的问题。认证的方式非常多，简单说来可以分为三类：    A. What you know? — 口令    B. What you have? — 数字证书（U盾、密保卡）    C. Who you are? — 指纹识别、虹膜识别    在Tomcat中可以通过建立安全套接字层（Secure Socket Layer, SSL）以及通过基本验证或表单验证来实现对安全性的支持。    说明：虽然JSTL标签库提供了core、sql、fmt、xml等标签库，但是实际开发中建议只使用核心标签库（core），而且最好只使用分支和循环标签并辅以表达式语言（EL），这样才能真正做到数据显示和业务逻辑的分离，这才是最佳实践。自定义JSP标签包括以下几个步骤：- 编写一个Java类实现实现Tag/BodyTag/IterationTag接口（开发中通常不直接实现这些接口而是继承TagSupport/BodyTagSupport/SimpleTagSupport类，这是对缺省适配模式的应用），重写doStartTag()、doEndTag()等方法，定义标签要完成的功能- 编写扩展名为tld的标签描述文件对自定义标签进行部署，tld文件通常放在WEB-INF文件夹下或其子目录中- 在JSP页面中使用taglib指令引用该标签库步骤1 - 标签类源代码TimeTag.java：import java.io.IOException;import java.text.SimpleDateFormat;import java.util.Date;public class TimeTag extends TagSupport {    private static final long serialVersionUID = 1L;    public int doStartTag() throws JspException {         SimpleDateFormat sdf = new SimpleDateFormat(format);         JspWriter writer = pageContext.getOut();         StringBuilder sb = new StringBuilder();         sb.append(String.format(“<span style="color:%s;background-color:%s">%s</span>“,             foreColor, backColor, sdf.format(new Date())));         try {           writer.print(sb.toString());         } catch(IOException e) {           e.printStackTrace();         }         return SKIP_BODY;      }    public void setForeColor(String foreColor) {        this.foreColor = foreColor;    }步骤2 - 编写标签库描述文件my.tld：    <description>定义标签库</description>    <tlib-version>1.0</tlib-version>    <short-name>MyTag</short-name>    <tag>        <name>time</name>        <tag-class>com.jackfrued.tags.TimeTag</tag-class>        <body-content>empty</body-content>        <attribute>            <name>format</name>            <required>false</required>        </attribute>        <attribute>            <name>foreColor</name>        </attribute>        <attribute>            <name>backColor</name>        </attribute>    </tag>&lt;%@ page pageEncoding=”UTF-8”%&gt;&lt;%@ taglib prefix=”my” uri=”/WEB-INF/tld/my.tld” %&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme() + “://“ + request.getServerName() + “:” + request.getServerPort() + path + “/“;%&gt;  <body>    &lt;my:time format=”yyyy-MM-dd” backColor=”blue” foreColor=”yellow”/&gt;  </body>111、说一下表达式语言（EL）的隐式对象及其作用。答：EL的隐式对象包括：pageContext、initParam（访问上下文参数）、param（访问请求参数）、paramValues、header（访问请求头）、headerValues、cookie（访问cookie）、applicationScope（访问application作用域）、sessionScope（访问session作用域）、requestScope（访问request作用域）、pageScope（访问page作用域）。${pageContext.request.method}${pageContext[“request”][“method”]}${pageContext.request[“method”]}${pageContext[“request”].method}${initParam.defaultEncoding}${header[“accept-language”]}${headerValues[“accept-language”][0]}${cookie.jsessionid.value}${sessionScope.loginUser.username}112、表达式语言（EL）支持哪些运算符？答：除了.和[]运算符，EL还提供了：- 算术运算符：+、-、*、/或div、%或mod- 关系运算符：==或eq、!=或ne、&gt;或gt、&gt;=或ge、&lt;或lt、&lt;=或le- 逻辑运算符：&amp;&amp;或and、||或or、!或not- 条件运算符：${statement? A : B}（跟Java的条件运算符类似）- empty运算符：检查一个值是否为null或者空（数组长度为0或集合中没有元素也返回true）</listener></p>
<p><strong>113、Java Web开发的Model 1和Model 2分别指的是什么？</strong><br>答：Model 1是以页面为中心的Java Web开发，使用JSP+JavaBean技术将页面显示逻辑和业务逻辑处理分开，JSP实现页面显示，JavaBean对象用来保存数据和实现业务逻辑。Model 2是基于MVC（模型-视图-控制器，Model-View-Controller）架构模式的开发模型，实现了模型和视图的彻底分离，利于团队开发和代码复用，如下图所示。</p>
<p><img src="https://img-blog.csdn.net/20150409102658882" alt="这里写图片描述"></p>
<pre><code>补充：多线程在Java诞生初期无疑是一个亮点，而Servlet单实例多线程的工作方式也曾为其赢得美名，然而技术的发展往往会颠覆我们很多的认知，就如同当年爱因斯坦的相对论颠覆了牛顿的经典力学一般。事实上，异步处理绝不是Serlvet 3首创，如果你了解Node.js的话，对Servlet 3的这个重要改进就不以为奇了。import java.io.IOException;import javax.servlet.AsyncContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;    @Override    public void doGet(HttpServletRequest req, HttpServletResponse resp)            throws ServletException, IOException {        // 开启Tomcat异步Servlet支持        req.setAttribute(&quot;org.apache.catalina.ASYNC_SUPPORTED&quot;, true);            @Override            public void run() {                // 在此处添加异步处理的代码115、如何在基于Java的Web项目中实现文件上传和下载？答：在Sevlet 3 以前，Servlet API中没有支持上传功能的API，因此要实现上传功能需要引入第三方工具从POST请求中获得上传的附件或者通过自行处理输入流来获得上传的文件，我们推荐使用Apache的commons-fileupload。从Servlet 3开始，文件上传变得无比简单，相信看看下面的例子一切都清楚了。&lt;%@ page pageEncoding=&quot;utf-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Photo Upload&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Select your photo and upload&lt;/h1&gt;&lt;hr/&gt;&lt;div style=&quot;color:red;font-size:14px;&quot;&gt;${hint}&lt;/div&gt;&lt;form action=&quot;UploadServlet&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    Photo file: &lt;input type=&quot;file&quot; name=&quot;photo&quot; /&gt;    &lt;input type=&quot;submit&quot; value=&quot;Upload&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;package com.jackfrued.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.MultipartConfig;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.Part;    protected void doPost(HttpServletRequest request,            HttpServletResponse response) throws ServletException, IOException {        // 可以用request.getPart()方法获得名为photo的上传附件        // 也可以用request.getParts()获得所有上传附件（多文件上传）        // 然后通过循环分别处理每一个上传的文件        Part part = request.getPart(&quot;photo&quot;);        if (part != null &amp;&amp; part.getSubmittedFileName().length() &gt; 0) {            // 用ServletContext对象的getRealPath()方法获得上传文件夹的绝对路径            String savePath = request.getServletContext().getRealPath(&quot;/upload&quot;);            // Servlet 3.1规范中可以用Part对象的getSubmittedFileName()方法获得上传的文件名            // 更好的做法是为上传的文件进行重命名（避免同名文件的相互覆盖）            part.write(savePath + &quot;/&quot; + part.getSubmittedFileName());            request.setAttribute(&quot;hint&quot;, &quot;Upload Successfully!&quot;);        } else {            request.setAttribute(&quot;hint&quot;, &quot;Upload failed!&quot;);        }        // 跳转回到上传页面        request.getRequestDispatcher(&quot;index.jsp&quot;).forward(request, response);    }116、服务器收到用户提交的表单数据，到底是调用Servlet的doGet()还是doPost()方法？答：HTML的&lt;form&gt;元素有一个method属性，用来指定提交表单的方式，其值可以是get或post。我们自定义的Servlet一般情况下会重写doGet()或doPost()两个方法之一或全部，如果是GET请求就调用doGet()方法，如果是POST请求就调用doPost()方法，那为什么为什么这样呢？我们自定义的Servlet通常继承自HttpServlet，HttpServlet继承自GenericServlet并重写了其中的service()方法，这个方法是Servlet接口中定义的。HttpServlet重写的service()方法会先获取用户请求的方法，然后根据请求方法调用doGet()、doPost()、doPut()、doDelete()等方法，如果在自定义Servlet中重写了这些方法，那么显然会调用重写过的（自定义的）方法，这显然是对模板方法模式的应用（如果不理解，请参考阎宏博士的《Java与模式》一书的第37章）。当然，自定义Servlet中也可以直接重写service()方法，那么不管是哪种方式的请求，都可以通过自己的代码进行处理，这对于不区分请求方法的场景比较合适。&lt;%-- 静态包含 --%&gt;&lt;%@ include file=&quot;...&quot; %&gt;118、Servlet中如何获取用户提交的查询参数或表单数据？答：可以通过请求对象（HttpServletRequest）的getParameter()方法通过参数名获得参数值。如果有包含多个值的参数（例如复选框），可以通过请求对象的getParameterValues()方法获得。当然也可以通过请求对象的getParameterMap()获得一个参数名和参数值的映射（Map）。120、如何设置请求的编码以及响应内容的类型？答：通过请求对象（ServletRequest）的setCharacterEncoding(String)方法可以设置请求的编码，其实要彻底解决乱码问题就应该让页面、服务器、请求和响应、Java程序都使用统一的编码，最好的选择当然是UTF-8；通过响应对象（ServletResponse）的setContentType(String)方法可以设置响应内容的类型，当然也可以通过HttpServletResponsed对象的setHeader(String, String)方法来设置。121、解释一下网络应用的模式及其特点。答：典型的网络应用模式大致有三类：B/S、C/S、P2P。其中B代表浏览器（Browser）、C代表客户端（Client）、S代表服务器（Server），P2P是对等模式，不区分客户端和服务器。B/S应用模式中可以视为特殊的C/S应用模式，只是将C/S应用模式中的特殊的客户端换成了浏览器，因为几乎所有的系统上都有浏览器，那么只要打开浏览器就可以使用应用，没有安装、配置、升级客户端所带来的各种开销。P2P应用模式中，成千上万台彼此连接的计算机都处于对等的地位，整个网络一般来说不依赖专用的集中服务器。网络中的每一台计算机既能充当网络服务的请求者，又对其它计算机的请求作出响应，提供资源和服务。通常这些资源和服务包括：信息的共享和交换、计算资源（如CPU的共享）、存储共享（如缓存和磁盘空间的使用）等，这种应用模式最大的阻力安全性、版本等问题，目前有很多应用都混合使用了多种应用模型，最常见的网络视频应用，它几乎把三种模式都用上了。122、什么是Web Service（Web服务）？答：从表面上看，Web Service就是一个应用程序，它向外界暴露出一个能够通过Web进行调用的API。这就是说，你能够用编程的方法透明的调用这个应用程序，不需要了解它的任何细节，跟你使用的编程语言也没有关系。例如可以创建一个提供天气预报的Web Service，那么无论你用哪种编程语言开发的应用都可以通过调用它的API并传入城市信息来获得该城市的天气预报。之所以称之为Web Service，是因为它基于HTTP协议传输数据，这使得运行在不同机器上的不同应用无须借助附加的、专门的第三方软件或硬件，就可相互交换数据或集成。123、概念解释：SOAP、WSDL、UDDI。答：- SOAP：简单对象访问协议（Simple Object Access Protocol），是Web Service中交换数据的一种协议规范。- WSDL：Web服务描述语言（Web Service Description Language），它描述了Web服务的公共接口。这是一个基于XML的关于如何与Web服务通讯和使用的服务描述；也就是描述与目录中列出的Web服务进行交互时需要绑定的协议和信息格式。通常采用抽象语言描述该服务支持的操作和信息，使用的时候再将实际的网络协议和信息格式绑定给该服务。- UDDI：统一描述、发现和集成（Universal Description, Discovery and Integration），它是一个基于XML的跨平台的描述规范，可以使世界范围内的企业在互联网上发布自己所提供的服务。简单的说，UDDI是访问各种WSDL的一个门面（可以参考设计模式中的门面模式）。124、Java规范中和Web Service相关的规范有哪些？答：Java规范中和Web Service相关的有三个：- JAX-WS(JSR 224)：这个规范是早期的基于SOAP的Web Service规范JAX-RPC的替代版本，它并不提供向下兼容性，因为RPC样式的WSDL以及相关的API已经在Java EE5中被移除了。WS-MetaData是JAX-WS的依赖规范，提供了基于注解配置Web Service和SOAP消息的相关API。- JAXM(JSR 67)：定义了发送和接收消息所需的API,相当于Web Service的服务器端。- JAX-RS(JSR 311 &amp; JSR 339 &amp; JSR 370)：是Java针对REST（Representation State Transfer）架构风格制定的一套Web Service规范。REST是一种软件架构模式，是一种风格，它不像SOAP那样本身承载着一种消息协议， (两种风格的Web Service均采用了HTTP做传输协议，因为HTTP协议能穿越防火墙，Java的远程方法调用（RMI）等是重量级协议，通常不能穿越防火墙），因此可以将REST视为基于HTTP协议的软件架构。REST中最重要的两个概念是资源定位和资源操作，而HTTP协议恰好完整的提供了这两个点。HTTP协议中的URI可以完成资源定位，而GET、POST、OPTION、DELETE方法可以完成资源操作。因此REST完全依赖HTTP协议就可以完成Web Service，而不像SOAP协议那样只利用了HTTP的传输特性，定位和操作都是由SOAP协议自身完成的，也正是由于SOAP消息的存在使得基于SOAP的Web Service显得笨重而逐渐被淘汰。    提示：面试被问到这类问题的时候一定选择自己用过的最熟悉的作答，如果之前没有了解过就应该在面试前花一些时间了解其中的两个，并比较其优缺点，这样才能在面试时给出一个漂亮的答案。这部分主要是开源Java EE框架方面的内容，包括Hibernate、MyBatis、Spring、Spring MVC等，由于Struts 2已经是明日黄花，在这里就不讨论Struts 2的面试题，如果需要了解相关内容，可以参考Java程序员面试题集（86-115）。127、持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？答：所谓&quot;持久&quot;就是将数据保存到可掉电式存储设备中以便今后使用，简单的说，就是将内存中的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。持久层就是系统中专注于实现数据持久化的相对独立的层面。持久层框架有：- Hibernate- MyBatis- TopLink- Guzz- jOOQ- Spring Data- ActiveJDBC129、Hibernate中Session的load和get方法的区别是什么？答：主要有以下三项区别：① 如果没有找到符合条件的记录，get方法返回null，load方法抛出异常。② get方法直接返回实体类对象，load方法返回实体类对象的代理。③ 在Hibernate 3之前，get方法只在一级缓存中进行数据查找，如果没有找到对应的数据则越过二级缓存，直接发出SQL语句完成数据读取；load方法则可以从二级缓存中获取数据；从Hibernate 3开始，get方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。130、Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？答：Hibernate的对象有三种状态：瞬时态（transient）、持久态（persistent）和游离态（detached），如第135题中的图所示。瞬时态的实例可以通过调用save()、persist()或者saveOrUpdate()方法变成持久态；游离态的实例可以通过调用 update()、saveOrUpdate()、lock()或者replicate()变成持久态。save()和persist()将会引发SQL的INSERT语句，而update()或merge()会引发UPDATE语句。save()和update()的区别在于一个是将瞬时态对象变成持久态，一个是将游离态对象变为持久态。merge()方法可以完成save()和update()方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。对于persist()方法，按照官方文档的说明：① persist()方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到flush的时间；② persist()方法保证当它在一个事务外部被调用的时候并不触发一个INSERT语句，当需要封装一个长会话流程的时候，persist()方法是很有必要的；③ save()方法不保证第②条，它要返回标识符，所以它会立即执行INSERT语句，不管是在事务内部还是外部。至于lock()方法和update()方法的区别，update()方法是把一个已经更改过的脱管状态的对象变成持久状态；lock()方法是把一个没有更改过的脱管状态的对象变成持久状态。132、Query接口的list方法和iterate方法有什么区别？答：① list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。② list()方法不会引起N+1查询问题，而iterate()方法可能引起N+1查询问题133、Hibernate如何实现分页查询？答：通过Hibernate实现分页查询，开发人员只需要提供HQL语句（调用Session的createQuery()方法）或查询条件（调用Session的createCriteria()方法）、设置查询起始行数（调用Query或Criteria接口的setFirstResult()方法）和最大查询行数（调用Query或Criteria接口的setMaxResults()方法），并调用Query或Criteria接口的list()方法，Hibernate会自动生成分页查询的SQL语句。    提示：使用乐观锁会增加了一个版本字段，很明显这需要额外的空间来存储这个版本字段，浪费了空间，但是乐观锁会让系统具有更好的并发性，这是对时间的节省。因此乐观锁也是典型的空间换时间的策略。</code></pre><p><strong>135、阐述实体对象的三种状态以及转换关系。</strong><br>答：最新的Hibernate文档中为Hibernate对象定义了四种状态（原来是三种状态，面试的时候基本上问的也是三种状态），分别是：瞬时态（new, or transient）、持久态（managed, or persistent）、游状态（detached）和移除态（removed，以前Hibernate文档中定义的三种状态中没有移除态），如下图所示，就以前的Hibernate文档中移除态被视为是瞬时态。</p>
<p><img src="https://img-blog.csdn.net/20150412180839610" alt="这里写图片描述"></p>
<pre><code>提示：关于这个问题，在Hibernate的官方文档中有更为详细的解读。</code></pre><p>延迟加载与session关闭的矛盾一般可以这样处理：① 关闭延迟加载特性。这种方式操作起来比较简单，因为Hibernate的延迟加载特性是可以通过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现”no session or session was closed”通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询的开销都会变得很大。② 在session关闭之前先获取需要查询的数据，可以使用工具方法Hibernate.isInitialized()判断对象是否被加载，如果没有被加载则可以使用Hibernate.initialize()方法加载对象。③ 使用拦截器或过滤器延长Session的生命周期直到视图获得数据。Spring整合Hibernate提供的OpenSessionInViewFilter和OpenSessionInViewInterceptor就是这种做法。</p>
<p>138、谈一下你对继承映射的理解。答：继承关系的映射策略有三种：① 每个继承结构一张表（table per class hierarchy），不管多少个子类都用一张表。② 每个子类一张表（table per subclass），公共信息放一张表，特有信息放单独的表。③ 每个具体类一张表（table per concrete class），有多少个子类就有多少张表。第一种方式属于单表策略，其优点在于查询子类对象的时候无需表连接，查询速度快，适合多态查询；缺点是可能导致表很大。后两种方式属于多表策略，其优点在于数据存储紧凑，其缺点是需要进行连接查询，不适合多态查询。</p>
<p>140、谈一谈Hibernate的一级缓存、二级缓存和查询缓存。答：Hibernate的Session提供了一级缓存的功能，默认总是有效的，当应用程序保存持久化实体、修改持久化实体时，Session并不会立即把这种改变提交到数据库，而是缓存在当前的Session中，除非显示调用了Session的flush()方法或通过close()方法关闭Session。通过一级缓存，可以减少程序与数据库的交互，从而提高数据库访问性能。SessionFactory级别的二级缓存是全局性的，所有的Session可以共享这个二级缓存。不过二级缓存默认是关闭的，需要显示开启并指定需要使用哪种二级缓存实现类（可以使用第三方提供的实现）。一旦开启了二级缓存并设置了需要使用二级缓存的实体类，SessionFactory就会缓存访问过的该实体类的每个对象，除非缓存的数据超出了指定的缓存空间。一级缓存和二级缓存都是对整个实体进行缓存，不会缓存普通属性，如果希望对普通属性进行缓存，可以使用查询缓存。查询缓存是将HQL或SQL语句以及它们的查询结果作为键值对进行缓存，对于同样的查询可以直接从缓存中获取数据。查询缓存默认也是关闭的，需要显示开启。</p>
<p>142、@OneToMany注解的mappedBy属性有什么作用？答：@OneToMany用来配置一对多关联映射，但通常情况下，一对多关联映射都由多的一方来维护关联关系，例如学生和班级，应该在学生类中添加班级属性来维持学生和班级的关联关系（在数据库中是由学生表中的外键班级编号来维护学生表和班级表的多对一关系），如果要使用双向关联，在班级类中添加一个容器属性来存放学生，并使用@OneToMany注解进行映射，此时mappedBy属性就非常重要。如果使用XML进行配置，可以用<set>标签的inverse=”true”设置来达到同样的效果。</set></p>
<p>144、解释一下MyBatis中命名空间（namespace）的作用。答：在大型项目中，可能存在大量的SQL语句，这时候为每个SQL语句起一个唯一的标识（ID）就变得并不容易了。为了解决这个问题，在MyBatis中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个SQL语句就成了定义在这个命名空间中的一个ID。只要我们能够保证每个命名空间中这个ID是唯一的，即使在不同映射文件中的语句ID相同，也不会再产生冲突了。</p>
<p>下面是映射文件的片段。</p>
<p>当然也可以像下面这些书写。</p>
<p>再看看下面这个例子。</p>
<p>146、什么是IoC和DI？DI是如何实现的？答：IoC叫控制反转，是Inversion of Control的缩写，DI（Dependency Injection）叫依赖注入，是对IoC更简单的诠释。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的”控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。IoC体现了好莱坞原则 - “Don’t call me, we will call you”。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。</p>
<p>依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。</p>
<pre><code>补充：设计模式中的创建型模式中也有一个原型模式，原型模式也是一个常用的模式，例如做一个室内设计软件，所有的素材都在工具箱中，而每次从工具箱中取出的都是素材对象的一个原型，可以通过对象克隆来实现原型模式。</code></pre><p>​    说明：单例模式和原型模式都是重要的设计模式。一般情况下，无状态或状态不可变的类适合使用单例模式。在传统开发中，由于DAO持有Connection这个非线程安全对象因而没有使用单例模式；但在Spring环境下，所有DAO类对可以采用单例模式，因为Spring利用AOP和Java API中的ThreadLocal对非线程安全的对象进行了特殊处理。</p>
<p>ThreadLocal类非常简单好用，只有四个方法，能用上的也就是下面三个方法：- void set(T value)：设置当前线程的线程局部变量的值。- T get()：获得当前线程所对应的线程局部变量的值。- void remove()：删除当前线程中线程局部变量的值。</p>
<p>import java.util.Collections;import java.util.HashMap;import java.util.Map;</p>
<pre><code>public void set(T newValue) {        map.put(Thread.currentThread(), newValue);    }</code></pre><p>​    public void remove() {        map.remove(Thread.currentThread());    }}</p>
<p>149、你是如何理解”横切关注”这个概念的？答：”横切关注”是会影响到整个应用程序的关注功能，它跟正常的业务逻辑是正交的，没有必然的联系，但是几乎所有的业务逻辑都会涉及到这些关注功能。通常，事务、日志、安全性等关注就是应用中的横切关注功能。</p>
<p>​    说明： Advice在国内的很多书面资料中都被翻译成”通知”，但是很显然这个翻译无法表达其本质，有少量的读物上将这个词翻译为”增强”，这个翻译是对Advice较为准确的诠释，我们通过AOP将横切关注功能加到原有的业务逻辑上，这就是对原有业务逻辑的一种增强，这种增强可以是前置增强、后置增强、返回后增强、抛异常时增强和包围型增强。</p>
<p>​    补充：代理模式是GoF提出的23种设计模式中最为经典的模式之一，代理模式是对象的结构模式，它给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。简单的说，代理对象可以完成比原对象更多的职责，当需要为原对象添加横切关注功能时，就可以使用原对象的代理对象。我们在打开Office系列的Word文档时，如果文档中有插图，当文档刚加载时，文档中的插图都只是一个虚框占位符，等用户真正翻到某页要查看该图片时，才会真正加载这张图，这其实就是对代理模式的使用，代替真正图片的虚框就是一个虚拟代理；Hibernate的load方法也是返回一个虚拟代理对象，等用户真正需要访问对象的属性时，才向数据库发出SQL语句获得真实对象。</p>
<pre><code>/**     * 答题     */    public void answerTheQuestions();}</code></pre><p>/** * 懒学生 * @author 骆昊 * */public class LazyStudent implements Candidate {    private String name;        // 姓名</p>
<p>​    @Override    public void answerTheQuestions() {        // 懒学生只能写出自己的名字不会答题        System.out.println(“姓名: “ + name);    }</p>
<p>​    public Gunman(Candidate target) {        this.target = target;    }</p>
<p>}</p>
<p>​    public static void main(String[] args) {        Candidate c = new Gunman(new LazyStudent(“王小二”));        c.answerTheQuestions();    }}</p>
<p>import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.List;</p>
<pre><code>public ListProxy(List&lt;T&gt; target) {        this.target = target;    }</code></pre><p>}</p>
<p>public class ProxyTest2 {</p>
<pre><code>说明：使用Java的动态代理有一个局限性就是代理的类必须要实现接口，虽然面向接口编程是每个优秀的Java程序都知道的规则，但现实往往不尽如人意，对于没有实现接口的类如何为其生成代理呢？继承！继承是最经典的扩展已有代码能力的手段，虽然继承常常被初学者滥用，但继承也常常被进阶的程序员忽视。CGLib采用非常底层的字节码生成技术，通过为一个类创建子类来生成代理，它弥补了Java动态代理的不足，因此Spring中动态代理和CGLib都是创建代理的重要手段，对于实现了接口的类就用动态代理为其生成代理类，而没有实现接口的类就用CGLib通过继承的方式为其创建代理。</code></pre><p>​    说明：自动装配没有自定义装配方式那么精确，而且不能自动装配简单属性（基本类型、字符串等），在使用时应注意。</p>
<p>&lt;context:component-scan base-package=”org.example”/&gt;</p>
<p>事务分为全局事务和局部事务。全局事务由应用服务器管理，需要底层服务器JTA支持（如WebLogic、WildFly等）。局部事务和底层采用的持久化方案有关，例如使用JDBC进行持久化时，需要使用Connetion对象来操作事务；而采用Hibernate进行持久化时，需要使用Session对象来操作事务。</p>
<p>Spring提供了如下所示的事务管理器。</p>
<table>
<thead>
<tr>
<th align="left">事务管理器实现类</th>
<th align="left">目标对象</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DataSourceTransactionManager</td>
<td align="left">注入DataSource</td>
</tr>
<tr>
<td align="left">HibernateTransactionManager</td>
<td align="left">注入SessionFactory</td>
</tr>
<tr>
<td align="left">JdoTransactionManager</td>
<td align="left">管理JDO事务</td>
</tr>
<tr>
<td align="left">JtaTransactionManager</td>
<td align="left">使用JTA管理事务</td>
</tr>
<tr>
<td align="left">PersistenceBrokerTransactionManager</td>
<td align="left">管理Apache的OJB事务</td>
</tr>
</tbody></table>
<p>编程式事务管理如下所示。     &lt;context:component-scan base-package=”com.jackfrued”/&gt;     <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">         <property name="driverClassName">             <value>${db.driver}</value>         </property>         <property name="url">             <value>${db.url}</value>         </property>         <property name="username">             <value>${db.username}</value>         </property>         <property name="password">             <value>${db.password}</value>         </property>     </bean>     <!-- JDBC事务管理器 -->     <bean id="transactionManager" class="org.springframework.jdbc.datasource.       DataSourceTransactionManager" 　scope="singleton">         <property name="dataSource">             <ref bean="dataSource">         </ref></property>     </bean>import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;@Repositorypublic class EmpDaoImpl implements EmpDao {    @Autowired    private JdbcTemplate jdbcTemplate;}import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.TransactionStatus;import org.springframework.transaction.support.TransactionCallbackWithoutResult;import org.springframework.transaction.support.TransactionTemplate;@Servicepublic class EmpServiceImpl implements EmpService {    @Autowired    private TransactionTemplate txTemplate;    @Autowired    private EmpDao empDao;            @Override            protected void doInTransactionWithoutResult(TransactionStatus txStatus) {                empDao.save(emp);            }        });    }}<?xml version="1.0" encoding="UTF-8"?><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemalocation="http://www.springframework.org/schema/beans           http://www.springframework.org/schema/beans/spring-beans-3.2.xsd           http://www.springframework.org/schema/context           http://www.springframework.org/schema/context/spring-context-3.2.xsd           http://www.springframework.org/schema/aop           http://www.springframework.org/schema/aop/spring-aop-3.2.xsd           http://www.springframework.org/schema/tx           http://www.springframework.org/schema/tx/spring-tx-3.2.xsd">    <!-- 配置通过自动生成代理实现AOP功能 -->    &lt;aop:aspectj-autoproxy /&gt;    <!-- 配置Spring提供的支持注解ORM映射的Hibernate会话工厂 -->    <bean id="sessionFactory" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean">        <!-- 通过setter注入数据源属性 -->        <property name="dataSource" ref="dataSource">        <!-- 配置实体类所在的包 -->        <property name="packagesToScan" value="com.jackfrued.entity">        <!-- 配置Hibernate的相关属性 -->        <property name="hibernateProperties">            <!-- 在项目调试完成后要删除show_sql和format_sql属性否则对性能有显著影响 -->            <value>                hibernate.dialect=org.hibernate.dialect.MySQL5Dialect            </value>        </property>    </property></property></bean>    <!-- 配置基于注解配置声明式事务 -->    &lt;tx:annotation-driven /&gt;package com.jackfrued.dao;import com.jackfrued.comm.QueryBean;import com.jackfrued.comm.QueryResult;    /<em>*     * 新增     * @param entity 业务实体对象     * @return 增加成功返回实体对象的标识     <em>/    public K save(E entity);    /*</em>     * 根据ID删除     * @param id 业务实体对象的标识     * @return 删除成功返回true否则返回false     <em>/    public boolean deleteById(K id);    /*</em>     * 根据ID查找业务实体对象     * @param id 业务实体对象的标识     * @return 业务实体对象对象或null     <em>/    public E findById(K id);    /*</em>     * 查找所有业务实体对象     * @return 装所有业务实体对象的列表容器     <em>/    public List<e> findAll();    /*</e></em>     * 分页查找业务实体对象     * @param queryBean 查询条件对象     * @param page 页码     * @param size 页面大小     * @return 查询结果对象     <em>/    public QueryResult<e> findByPage(QueryBean queryBean, int page, int size);package com.jackfrued.dao;import com.jackfrued.comm.QueryBean;import com.jackfrued.comm.QueryResult;    @Override    public K save(E entity) {        return null;    }    @Override    public boolean deleteById(K id) {        E entity = findById(id);        if(entity != null) {            delete(entity);            return true;        }        return false;    }    @Override    public E findById(K id) {        return null;    }    @Override    public List<e> findAll() {        return null;    }    @Override    public QueryResult<e> findByPage(QueryBean queryBean, int page, int size) {        return null;    }package com.jackfrued.dao;import org.hibernate.Query;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.springframework.beans.factory.annotation.Autowired;/*</e></e></e></em> * 基于Hibernate的BaseDao实现类 * @author 骆昊 * * @param <e> 实体类型 * @param <k> 主键类型 <em>/@SuppressWarnings(value = {“unchecked”})public abstract class BaseDaoHibernateImpl&lt;E, K extends Serializable&gt; extends BaseDaoAdapter&lt;E, K&gt; {    @Autowired    protected SessionFactory sessionFactory;    public BaseDaoHibernateImpl() {        ParameterizedType pt = (ParameterizedType) this.getClass().getGenericSuperclass();        entityClass = (Class&lt;?&gt;) pt.getActualTypeArguments()[0];        entityName = entityClass.getSimpleName();    }    @Override    public void delete(E entity) {        sessionFactory.getCurrentSession().delete(entity);    }    @Override    public E findById(K id) {        return findById(id, false);    }    @Override    public List<e> findAll() {        return sessionFactory.getCurrentSession().createCriteria(entityClass).list();    }    @Override    public QueryResult<e> findByPage(QueryBean queryBean, int page, int size) {        if(queryBean instanceof HQLQueryBean) {            HQLQueryBean hqlQueryBean = (HQLQueryBean) queryBean;            return new QueryResult<e>(                findByHQLAndPage(hqlQueryBean.getQueryString(), page, size, hqlQueryBean.getParameters()),                getCountByHQL(hqlQueryBean.getCountString(), hqlQueryBean.getParameters())            );        }        return null;    }    /*</e></e></e></em>     * 根据HQL和参数列表进行查询     * @param hql 基于HQL的查询语句     * @param params 查询参数列表     * @return 持有查询结果的列表容器或空列表容器     <em>/    protected List<e> findByHQL(String hql, List<object> params) {        List<e> list = createQuery(hql, params).list();        return list != null &amp;&amp; list.size() &gt; 0 ? list : Collections.EMPTY_LIST;    }    /*</e></object></e></em>     * 根据HQL和参数列表进行分页查询     * @param hql 基于HQL的查询语句     * @page 页码     * @size 页面大小     * @param params 查询参数列表     * @return 持有查询结果的列表容器或空列表容器     <em>/    protected List<e> findByHQLAndPage(String hql, int page, int size, List<object> params) {        List<e> list = createQuery(hql, params)                .setFirstResult((page - 1) * size)                .setMaxResults(size)                .list();        return list != null &amp;&amp; list.size() &gt; 0 ? list : Collections.EMPTY_LIST;    }    /*</e></object></e></em>     * 查询满足条件的记录数     * @param hql 基于HQL的查询语句     * @param params 参数列表容器     * @return 满足查询条件的总记录数     <em>/    protected long getCountByHQL(String hql, List<object> params) {        return (Long) createQuery(hql, params).uniqueResult();    }    // 将可变参数列表组装成列表容器    private List<object> getParamList(Object… params) {        List<object> paramList = new ArrayList&lt;&gt;();        if(params != null) {            for(int i = 0; i &lt; params.length; i++) {                paramList.add(params[i]);            }        }        return paramList.size() == 0? Collections.EMPTY_LIST : paramList;    }package com.jackfrued.comm;/*</object></object></object></em> * 查询条件的接口 * @author 骆昊 * <em>/public interface QueryBean {    /*</em>     * 添加排序字段     * @param available 是否添加此排序字段     * @param fieldName 用于排序的字段     * @param asc 升序还是降序     * @return 查询条件对象自身(方便级联编程)     <em>/    public QueryBean addOrder(boolean available, String fieldName, boolean asc);    /*</em>     * 添加查询条件     * @param available 是否需要添加此条件     * @param condition 条件     * @param params 替换掉条件中参数占位符的参数     * @return 查询条件对象自身(方便级联编程)     <em>/    public QueryBean addCondition(boolean available, String condition, Object… params);    /*</em>     * 获取查询记录数的查询语句     * @return 查询记录数的查询语句     <em>/    public String getCountString();package com.jackfrued.comm;/*</em> * 查询结果 * @author 骆昊 * * @param <t> 泛型参数 <em>/public class QueryResult<t> {    private List<t> result;     // 持有查询结果的列表容器    private long totalRecords;  // 查询到的总记录数    /*</t></t></em>     * 构造器     * @param result 持有查询结果的列表容器     * @param totalRecords 查询到的总记录数     <em>/    public QueryResult(List<t> result, long totalRecords) {        this.result = result;        this.totalRecords = totalRecords;    }    public void setResult(List<t> result) {        this.result = result;    }    public void setTotalRecords(long totalRecords) {        this.totalRecords = totalRecords;    }}import com.jackfrued.comm.QueryResult;import com.jackfrued.entity.Dept;    /*</t></t></em>     * 分页查询顶级部门     * @param page 页码     * @param size 页码大小     * @return 查询结果对象     <em>/    public QueryResult<dept> findTopDeptByPage(int page, int size);package com.jackfrued.dao.impl;import org.springframework.stereotype.Repository;@Repositorypublic class DeptDaoImpl extends BaseDaoHibernateImpl&lt;Dept, Integer&gt; implements DeptDao {    private static final String HQL_FIND_TOP_DEPT = “ from Dept as d where d.superiorDept is null “;}import java.util.List;    private List<t> data;           // 分页数据    private PageRange pageRange;    // 页码范围    private int totalPage;          // 总页数    private int size;               // 页面大小    private int currentPage;        // 当前页码    private int pageCount;          // 页码数量    /*</t></dept></em>     * 构造器     * @param currentPage 当前页码     * @param size 页码大小     <em>/    public PageBean(int currentPage, int size) {        this(currentPage, size, DEFAULT_PAGE_COUNT);    }    /*</em>     * 构造器     <em>/    public PageBean() {        this(DEFAUL_INIT_PAGE, DEFAULT_PAGE_SIZE, DEFAULT_PAGE_COUNT);    }    public int getStartPage() {        return pageRange != null ? pageRange.getStartPage() : 1;    }    public long getTotalPage() {        return totalPage;    }    public int getCurrentPage() {        return currentPage;    }        data = queryResult.getResult();        totalPage = (int) ((totalRecords + size - 1) / size);        totalPage = totalPage &gt;= 0 ? totalPage : Integer.MAX_VALUE;        this.pageRange = new PageRange(pageCount, currentPage, totalPage);    }package com.jackfrued.comm;    /*</em>     * 构造器     * @param pageCount 总共显示几个页码     * @param currentPage 当前页码     * @param totalPage 总页数     <em>/    public PageRange(int pageCount, int currentPage, int totalPage) {        startPage = currentPage - (pageCount - 1) / 2;        endPage = currentPage + pageCount / 2;        if(startPage &lt; 1) {            startPage = 1;            endPage = totalPage &gt; pageCount ? pageCount : totalPage;        }        if (endPage &gt; totalPage) {            endPage = totalPage;            startPage = (endPage - pageCount &gt; 0) ? endPage - pageCount + 1 : 1;        }    }    /*</em>     * 获得终止页页码     * @return 终止页页码     <em>/    public int getEndPage() {        return endPage;    }package com.jackfrued.biz;/*</em> * 部门业务逻辑接口 * @author 骆昊 * <em>/public interface DeptService {    /*</em>     * 删除指定部门     * @param id 要删除的部门的编号     * @return 删除成功返回true否则返回false     */    public boolean deleteDepartment(Integer id);}import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Service@Transactional  // 声明式事务的注解public class DeptServiceImpl implements DeptService {    @Autowired    private DeptDao deptDao;    @Override    public boolean deleteDepartment(Integer id) {        return deptDao.deleteById(id);    }}<context-param>    <param-name>contextConfigLocation</param-name>    <param-value>classpath:applicationContext.xml</param-value></context-param>    说明：上面的配置中使用了</t></k></e></em>.html的后缀映射，这样做一方面不能够通过URL推断采用了何种服务器端的技术，另一方面可以欺骗搜索引擎，因为搜索引擎不会搜索动态页面，这种做法称为伪静态化。        <servlet>            <servlet-name>example</servlet-name>            <servlet-class>                org.springframework.web.servlet.DispatcherServlet            </servlet-class>            <load-on-startup>1</load-on-startup>        </servlet>    157、如何在Spring IoC容器中配置数据源？答：DBCP配置：&lt;context:property-placeholder location=”jdbc.properties”/&gt;<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close">    <property name="driverClass" value="${jdbc.driverClassName}">    <property name="jdbcUrl" value="${jdbc.url}">    <property name="user" value="${jdbc.username}">    <property name="password" value="${jdbc.password}"></property></property></property></property></bean>    提示： DBCP的详细配置在第153题中已经完整的展示过了。<?xml version="1.0" encoding="UTF-8"?><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemalocation="     http://www.springframework.org/schema/beans     http://www.springframework.org/schema/beans/spring-beans.xsd     http://www.springframework.org/schema/tx     http://www.springframework.org/schema/tx/spring-tx.xsd     http://www.springframework.org/schema/aop     http://www.springframework.org/schema/aop/spring-aop.xsd">  <!-- the transactional advice -->  &lt;tx:advice id=”txAdvice” transaction-manager=”txManager”&gt;  <!-- the transactional semantics... -->  <a href="tx:attributes" target="_blank" rel="noopener">tx:attributes</a>    <!-- all methods starting with 'get' are read-only -->    &lt;tx:method name=”get*” read-only=”true”/&gt;    <!-- other methods use the default transaction settings (see below) -->    &lt;tx:method name=”*”/&gt;      <!-- don't forget the DataSource -->  <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">  <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver">  <property name="url" value="jdbc:oracle:thin:@localhost:1521:orcl">  <property name="username" value="scott">  <property name="password" value="tiger">  </property></property></property></property></bean>  <!-- other <bean/> definitions here -->159、选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？答：可以从以下几个方面作答：- 非侵入式：支持基于POJO的编程模式，不强制性的要求实现Spring框架中的接口或继承Spring框架中的类。- IoC容器：IoC容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建和完整的回归测试。有了IoC容器，程序员再也不需要自己编写工厂、单例，这一点特别符合Spring的精神”不要重复的发明轮子”。- AOP（面向切面编程）：将所有的横切关注功能封装到切面（aspect）中，通过配置的方式将横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，有了AOP程序员可以省去很多自己写代理类的工作。- MVC：Spring的MVC框架是非常优秀的，从各个方面都可以甩Struts 2几条街，为Web表示层提供了更好的解决方案。- 事务管理：Spring以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，在不需要任何一行代码的情况下就能够完成事务管理。- 其他：选择Spring框架的原因还远不止于此，Spring为Java企业级开发提供了一站式选择，你可以在需要的时候使用它的部分和全部，更重要的是，你甚至可以在感觉不到Spring存在的情况下，在你的项目中使用Spring提供的各种优秀的功能。package com.jackfrued.bean;@Componentpublic class Person {    private String name;    private int age;    @Autowired    private Car car;    public void setCar(Car car) {        this.car = car;    }}import org.springframework.stereotype.Component;    public Car(String brand, int maxSpeed) {        this.brand = brand;        this.maxSpeed = maxSpeed;    }}import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class AppConfig {    @Bean    public Person person() {        return new Person(“骆昊”, 34);    }}import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;class Test {161、阐述Spring框架中Bean的生命周期？答：① Spring IoC容器找到关于Bean的定义并实例化该Bean。② Spring IoC容器对Bean进行依赖注入。③ 如果Bean实现了BeanNameAware接口，则将该Bean的id传给setBeanName方法。④ 如果Bean实现了BeanFactoryAware接口，则将BeanFactory对象传给setBeanFactory方法。⑤ 如果Bean实现了BeanPostProcessor接口，则调用其postProcessBeforeInitialization方法。⑥ 如果Bean实现了InitializingBean接口，则调用其afterPropertySet方法。⑦ 如果有和Bean关联的BeanPostProcessors对象，则这些对象的postProcessAfterInitialization方法被调用。⑧ 当销毁Bean实例时，如果Bean实现了DisposableBean接口，则调用其destroy方法。163、Spring中的自动装配有哪些限制？答：- 如果使用了构造器注入或者setter注入，那么将覆盖自动装配的依赖关系。- 基本数据类型的值、字符串字面量、类字面量无法使用自动装配来注入。- 优先考虑使用显式的装配来进行更精确的依赖注入而不是使用自动装配。WebApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext);166、你用过的网站前端优化的技术有哪些？答：① 浏览器访问优化：- 减少HTTP请求数量：合并CSS、合并JavaScript、合并图片（CSS Sprite）- 使用浏览器缓存：通过设置HTTP响应头中的Cache-Control和Expires属性，将CSS、JavaScript、图片等在浏览器中缓存，当这些静态资源需要更新时，可以更新HTML文件中的引用来让浏览器重新请求新的资源- 启用压缩- CSS前置，JavaScript后置- 减少Cookie传输② CDN加速：CDN（Content Distribute Network）的本质仍然是缓存，将数据缓存在离用户最近的地方，CDN通常部署在网络运营商的机房，不仅可以提升响应速度，还可以减少应用服务器的压力。当然，CDN缓存的通常都是静态资源。③ 反向代理：反向代理相当于应用服务器的一个门面，可以保护网站的安全性，也可以实现负载均衡的功能，当然最重要的是它缓存了用户访问的热点资源，可以直接从反向代理将某些内容返回给用户浏览器。</beans></beans></p>
<p><img src="https://img-blog.csdn.net/20150414123625761" alt="这里写图片描述"></p>
<blockquote>
<p><strong>补充：</strong>防火墙的架设是Web安全的重要保障，<a href="http://www.modsecurity.org/" target="_blank" rel="noopener">ModSecurity</a>是开源的Web防火墙中的佼佼者。企业级防火墙的架设应当有两级防火墙，Web服务器和部分应用服务器可以架设在两级防火墙之间的DMZ，而数据和资源服务器应当架设在第二级防火墙之后。</p>
</blockquote>
<p><strong>169. 什么是领域模型(domain model)？贫血模型(anaemic domain model)和充血模型(rich domain model)有什么区别？</strong><br>答：领域模型是领域内的概念类或现实世界中对象的可视化表示，又称为概念模型或分析对象模型，它专注于分析问题领域本身，发掘重要的业务领域概念，并建立业务领域概念之间的关系。贫血模型是指使用的领域对象中只有setter和getter方法（POJO），所有的业务逻辑都不包含在领域对象中而是放在业务逻辑层。有人将我们这里说的贫血模型进一步划分成失血模型（领域对象完全没有业务逻辑）和贫血模型（领域对象有少量的业务逻辑），我们这里就不对此加以区分了。充血模型将大多数业务逻辑和持久化放在领域对象中，业务逻辑（业务门面）只是完成对业务逻辑的封装、事务和权限等的处理。下面两张图分别展示了贫血模型和充血模型的分层架构。</p>
<p>贫血模型<br><img src="https://img-blog.csdn.net/20150414123848158" alt="这里写图片描述"></p>
<p>充血模型<br><img src="https://img-blog.csdn.net/20150414123813701" alt="这里写图片描述"></p>
<p>贫血模型下组织领域逻辑通常使用事务脚本模式，让每个过程对应用户可能要做的一个动作，每个动作由一个过程来驱动。也就是说在设计业务逻辑接口的时候，每个方法对应着用户的一个操作，这种模式有以下几个有点：<br>- 它是一个大多数开发者都能够理解的简单过程模型（适合国内的绝大多数开发者）。<br>- 它能够与一个使用行数据入口或表数据入口的简单数据访问层很好的协作。<br>- 事务边界的显而易见，一个事务开始于脚本的开始，终止于脚本的结束，很容易通过代理（或切面）实现声明式事务。<br>然而，事务脚本模式的缺点也是很多的，随着领域逻辑复杂性的增加，系统的复杂性将迅速增加，程序结构将变得极度混乱。开源中国社区上有一篇很好的译文<a href="http://www.oschina.net/translate/how-anaemic-domain-models-cause-bad-software" target="_blank" rel="noopener">《贫血领域模型是如何导致糟糕的软件产生》</a>对这个问题做了比较细致的阐述。</p>
<p><strong>170. 谈一谈测试驱动开发（TDD）的好处以及你的理解。</strong><br>答：TDD是指在编写真正的功能实现代码之前先写测试代码，然后根据需要重构实现代码。在JUnit的作者Kent Beck的大作《测试驱动开发：实战与模式解析》（Test-Driven Development: by Example）一书中有这么一段内容：“消除恐惧和不确定性是编写测试驱动代码的重要原因”。因为编写代码时的恐惧会让你小心试探，让你回避沟通，让你羞于得到反馈，让你变得焦躁不安，而TDD是消除恐惧、让Java开发者更加自信更加乐于沟通的重要手段。TDD会带来的好处可能不会马上呈现，但是你在某个时候一定会发现，这些好处包括：<br>- 更清晰的代码 — 只写需要的代码<br>- 更好的设计<br>- 更出色的灵活性 — 鼓励程序员面向接口编程<br>- 更快速的反馈 — 不会到系统上线时才知道bug的存在</p>
<blockquote>
<p><strong>补充：</strong>敏捷软件开发的概念已经有很多年了，而且也部分的改变了软件开发这个行业，TDD也是敏捷开发所倡导的。</p>
</blockquote>
<p>TDD可以在多个层级上应用，包括单元测试（测试一个类中的代码）、集成测试（测试类之间的交互）、系统测试（测试运行的系统）和系统集成测试（测试运行的系统包括使用的第三方组件）。TDD的实施步骤是：红（失败测试）- 绿（通过测试） - 重构。<br>在使用TDD开发时，经常会遇到需要被测对象需要依赖其他子系统的情况，但是你希望将测试代码跟依赖项隔离，以保证测试代码仅仅针对当前被测对象或方法展开，这时候你需要的是测试替身。测试替身可以分为四类：<br>- 虚设替身：只传递但是不会使用到的对象，一般用于填充方法的参数列表<br>- 存根替身：总是返回相同的预设响应，其中可能包括一些虚设状态<br>- 伪装替身：可以取代真实版本的可用版本（比真实版本还是会差很多）<br>- 模拟替身：可以表示一系列期望值的对象，并且可以提供预设响应 </p>
<p>Java世界中实现模拟替身的第三方工具非常多，包括EasyMock、Mockito、jMock等。</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/09/04/2019-9-4-docker-redis/" rel="next" title="2019-9-4-docker-redis">
                  <i class="fa fa-chevron-left"></i> 2019-9-4-docker-redis
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">田松</p>
  <div class="site-description motion-element" itemprop="description">真心喜欢应该是宁愿自己妥协也不会舍得骂人的 如果骂人，哪里有什么真诚在里面 我不想因为你哭了</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/fengleng" title="GitHub &rarr; https://github.com/fengleng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>




        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">1.</span> <span class="nav-text">Hello, World!</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.1.</span> <span class="nav-text">Current time is: &lt;%= new java.util.Date().toString() %&gt;</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">2.</span> <span class="nav-text">Hello, World!</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">2.1.</span> <span class="nav-text">Current time is: “);            out.print(new java.util.Date().toString());            out.write(“</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fas fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">田松</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.3.0</div>-->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共55.3k字</span>
</div>


        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>

<script src="/js/schemes/pisces.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  




























  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script><script src="/js/post-details.js?v=7.3.0"></script>


<script type="text/javascript" src="/js/src/clicklove.js"></script>
<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
<!-- 动态背景 -->
<!-- 页面点击小红心 -->

